<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Announce: ciphersurfer v1.0.0</title>
    <meta name="viewport" content="width=device-width">
    <meta content = "Paolo Perego" name = "author" />

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/stylesheets/syntax.css">

    <link href = "/stylesheets/bootstrap.min.css" rel = "stylesheet" />
    <link href = "/stylesheets/bootstrap-responsive.min.css" rel = "stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/stylesheets/thesp0nge.css">

    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22125982-1']);
      _gaq.push(['_setDomainName', 'thesp0nge.com']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>

  </head>
  <body>

        <!-- NAVBAR
    ================================================== -->
    <div class="navbar-wrapper">
      <!-- Wrap the .navbar in .container to center it within the absolutely positioned parent. -->
      <div class="container">

        <div class="navbar">
          <div class="navbar-inner">
            <a class="brand" href="/">Paolo Perego</a>
            <!-- Responsive Navbar Part 2: Place all navbar contents you want collapsed withing .navbar-collapse.collapse. -->
            <div class="nav-collapse collapse">
              <ul class="nav">
                <li class="active"><a href="/">Home</a></li>
                <li><a href="/blog">Blog</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
            </div><!--/.nav-collapse -->
          </div><!-- /.navbar-inner -->
        </div><!-- /.navbar -->

      </div> <!-- /.container -->
    </div><!-- /.navbar-wrapper -->

    <div class="container marketing">
      <h2>Announce: ciphersurfer v1.0.0</h2>
<p class="meta">01 Feb 2012</p>
<div>
<p>This article will take about 6  minutes minutes to read.</p>
</div>

<div class="post">
<p>After a week since the first
<a href="http://thesp0nge.com/blog/2012/01/25/is-my-connection-really-secure/">post</a>
about ciphersurfer and the early stage of testing an HTTPS communication, the
first <strong>major</strong> release it&#39;s available.</p>

<p>The project goals are now slightly different than just enumerating ciphers an
HTTPS server supports. Now a full evaluation is performed over the SSL
configuration giving a score using <a href="https://www.ssllabs.com/downloads/SSL_Server_Rating_Guide_2009.pdf">SSLabs document</a>
as reference guide. </p>

<!-- more -->

<p>The HTTPS connection is evaluated for <em>three</em> KPIs:</p>

<ul>
<li>protocols the server supports</li>
<li>cipher length</li>
<li>certificate key length</li>
</ul>

<p>The application you can find to the <a href="https://www.ssllabs.com">SSLabs website</a>
also gives an additional score for the certificate but, since the last one
doesn&#39;t infere with the overall security score, I decided not to hack further
and hit the web with a 1.0.0 release.</p>

<p>For the ones scared about what the tool does in order to evaluate your website
security configuration, ciphersurfer performs neither of the followings:</p>

<ul>
<li>denial of service attacks</li>
<li>cross site scripting or injection attempts</li>
<li>data manipulation or leakage</li>
</ul>

<p>The requests the tool makes are just an HTTP GET / of target website to ensure
the server accept an HTTP communication given a SSL protocol and cipher
proposed by the client. No more. Really, ciphersurer won&#39;t hurt your webserver,
nor your business. </p>

<p>If you don&#39;t trust this disclaimer, just check the source code.</p>

<h2>Installing ciphersurfer</h2>

<p>ciphersurfer is deployed as standard gem served by
<a href="http://rubygems.org">rubygems</a>. </p>

<p>To install latest ciphersurfer stable release, just issue this command:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gem install ciphersurfer
</code></pre></div>
<p>If you want to install a <em>pre</em> release, such as a <em>release candidate</em> you can do it this way:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gem install ciphersurfer --pre
</code></pre></div>
<p>I recommend you to install <a href="https://rvm.beginrescueend.com/">rvm</a> in order to
have your gem binaries tool installed in your home directory, otherwise
ciphersurfer will try to install itself in standard /usr/bin directory if no
other flags are passed to gem command.</p>

<h2>Using ciphersurfer</h2>

<p>After ciphersurfer has been installed, using it it&#39;s very simple.</p>

<p>To evaluate secure communication with the target host <em>test-this.com</em> at the
standard HTTPS port, you just give the tool the target name as option:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ciphersurfer test-this.com
</code></pre></div>
<p>As output you will see an evaluation for HTTPS test-this.com configuration. 
The evaluation scale is:</p>

<ul>
<li>A: <em>prime class</em> HTTPS configuration. Servers handling <strong>very</strong> sensitive
information</li>
<li>B: strong HTTPS configuration, suitable for must production servers</li>
<li>C: quite goot HTTPS configuration. If your web server is a private server and
for development or testing purposes, it can be acceptable. If your server is
exposed to the Internet, you want to improve your SSL configuration.</li>
<li>D: poor HTTPS configuration. Suitable <strong>only</strong> for development machines.</li>
<li>E: weak HTTPS configuration. You really don&#39;t want to have this score</li>
</ul>

<p>As example, this is the evaluation for <a href="https://www.pec.it">www.pec.it</a>, ran
with official 1.0.0 ruby gem.</p>

<p><img src="/images/ciphersurfer_eval-1036x175-5ceeac.png" ></p>

<p>You can also just listen ciphers supported by your web server instead of having
an SSL evaluation:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ ciphersurfer -l gmail.com 

&quot;Evaluating secure communication with gmail.com:443&quot;
&quot;[+] accepted RC4-MD5&quot;
&quot;[+] accepted AES256-SHA&quot;
&quot;[+] accepted DES-CBC3-SHA&quot;
&quot;[+] accepted AES128-SHA&quot;
&quot;[+] accepted RC4-SHA&quot;
</code></pre></div>
<h2>Show me the code dude</h2>

<p>Funny isn&#39;t it? Well the code has changed a lot since last post.</p>

<p>The first <em>major</em> change is that for all regular HTTP GETs, the ruby library
<strong>httpclient</strong> has been used instead of cooking a connection using Net::HTTP
class. This because httpclient makes me easy to grab the server certificate
since it bundles all root CAs without them Net::HTTP class won&#39;t give me
anything as peer certificate.</p>

<p>This is the routine available at Ciphersurfer::Scanner.alive? It just checks if
a server answers if prompted for the root page. As you can see we grab also the
certificate so we don&#39;t need to bother the target with another get just to take
it.</p>

<p>``` ruby lib/ciphersurfer/scanner.rb
def self.alive?(host, port)
  client=HTTPClient.new
  begin
    @alive=true
    response=client.get(&quot;https://#{host}:#{port}&quot;)
    @peer<em>cert = response.peer</em>cert
    return true
  rescue =&gt; e
    puts &quot;alive?(): #{e.message}&quot;.color(:red)
    return false
  end</p>

<p>end
```</p>

<p>The core scanning method hasn&#39;t changed a lot. Just a minor difference in how
results are stored.</p>

<p>``` ruby lib/ciphersurfer/scanner.rb
def go
  context=OpenSSL::SSL::SSLContext.new(@proto)
  cipher<em>set = context.ciphers
  cipher</em>set.each do |cipher<em>name, cipher</em>version, bits, algorithm_bits|</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">request = Net::HTTP.new(@host, @port)
request.use_ssl = true
request.verify_mode = OpenSSL::SSL::VERIFY_NONE
request.ciphers= cipher_name
begin
  response = request.get(&quot;/&quot;)
  @ok_bits &lt;&lt; bits
  @ok_ciphers &lt;&lt; cipher_name
rescue OpenSSL::SSL::SSLError =&gt; e
  # Quietly discard SSLErrors, really I don&#39;t care if the cipher has
  # not been accepted
rescue 
  # Quietly discard all other errors... you must perform all error
  # chekcs in the calling program
end
</code></pre></div>
<p>end
end
```</p>

<p>Here we don&#39;t use httpclient helpers since I want to play with different
ciphers at time.</p>

<p>That&#39;s it. All the magic happens there. Now, let&#39;s look like at the bin script to see how the scoring system has been used.</p>

<p>First of all, we must scan the target for all the protocols we support.</p>

<p>``` ruby bin/ciphersurfer
protocol_version.each do |version|
  s = Ciphersurfer::Scanner.new({:host=&gt;host, :port=&gt;port, :proto=&gt;version})</p>

<p>s.go
  if (s.ok<em>ciphers.size != 0)
    supported</em>protocols &lt;&lt; version
    cipher<em>bits = cipher</em>bits | s.ok<em>bits
    ciphers = ciphers | s.ok</em>ciphers
  end</p>

<p>end
```</p>

<p>Now we&#39;ve got supported<em>protocols that stores all the protocols the server
supports, and cipher</em>bits that stores all the ciphers length in bits. We want
the certificate now.</p>

<p><code>ruby bin/ciphersurfer
cert= Ciphersurfer::Scanner.cert(host, port)
if ! cert.nil?
  a=cert.public_key.to_text
  key_size=/Modulus \((\d+)/i.match(a)[1]
else
  puts &quot;warning: the server didn&#39;t give us the certificate&quot;.color(:yellow)
  key_size=0
end
</code></p>

<p>Note that we don&#39;t make another GET here since we did it at the beginning of
the engagement when we checked if the target was alive or not.</p>

<p>Now, let&#39;s calculate the scores, all of them in a 0..100 range.</p>

<p><code>ruby bin/ciphersurfer
proto_score=  Ciphersurfer::Score.evaluate_protocols(supported_protocols)
cipher_score= Ciphersurfer::Score.evaluate_ciphers(cipher_bits)
key_score=    Ciphersurfer::Score.evaluate_key(key_size.to_i)
score=        Ciphersurfer::Score.score(proto_score, key_score, cipher_score)
</code></p>

<p>And then, some graphics to make the experience more appealing.</p>

<p><code>ruby bin/ciphersurfer
printf &quot;%20s : %s (%s)\n&quot;, &quot;Overall evaluation&quot;, Ciphersurfer::Score.evaluate(score), score.to_s
printf &quot;%20s : &quot;, &quot;Protocol support&quot; 
proto_score.to_i.times{print &#39;o&#39;.color(score_to_color(proto_score))}
puts &#39; (&#39;+proto_score.to_s+&#39;)&#39;
printf &quot;%20s : &quot;,  &quot;Key exchange&quot; 
key_score.to_i.times{print &#39;o&#39;.color(score_to_color(key_score))}
puts &#39; (&#39;+key_score.to_s+&#39;)&#39;
printf &quot;%20s : &quot;, &quot;Cipher strength&quot; 
cipher_score.to_i.times{print &#39;o&#39;.color(score_to_color(cipher_score))}
puts &#39; (&#39;+cipher_score.to_s+&#39;)&#39;
</code></p>

<p>Results can be optained also in a JSON format, so ciphersurfer can be embedded
in other tools or even in a web app.</p>

<h2>Further improvements</h2>

<p>Well, the major improvement I&#39;m going to introduce later on is a scan on some
certificate parameter to check if the certficate is still valid or if it&#39;s self
signed or if it matches the FQDN the tester asked.</p>

<p>Later some sort of persistence in a SQL database will be introduced to save the
scan history for a given target, in order to make evaluation over time if
actions were taken to improve HTTPS configuration or not.</p>

</div>



      <div class="row"> <hr /> </div>
      <footer>
      <p class="pull-right"><a href="#">Back to top</a></p>
      <p>&copy; 2013 thesp0nge.com &middot; v4.0.0.rc1 &middot; <a href="#">Privacy</a> &middot; <a href="#">Terms</a></p>
      </footer>

    </div>

    <!-- /container -->
    <script src='/javascripts/jquery.js'></script>
    <script src='/javascripts/bootstrap.min.js'></script>
    <script src='/javascripts/holder.js'></script>
  </body>
</html>
